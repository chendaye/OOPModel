<?php
/**
 * 模板视图是php天生具有的功能，可以将HTML和php代码结合起来
 * 这一点既有好处也有坏处
 * 好处是：可以很方便的将模板和代码结合起来，提高开发效率
 * 坏处是：将视图和代码结合起来会给将来的后续开发和长期维护带来很糟的后果
 *
 * php编程时，在视图里编程应该尽力避免；如果视图中混入了业务代码就会难以维护
 * 因为HTML被放到各种条件语句和循环之中
 *
 * 问题：
 * 现在已经很少在页面里直接嵌入sql查询和其他业务逻辑了，但此种情况并未完全消失
 * web页面中包含业务代码会让前端犯难；因为HTML会出现在各种条件语句、循环语句中
 * 表现层中加入业务逻辑还会增大代码的耦合；如果要增加一个新的视图就不得不复制粘贴大量的业务逻辑到新视图中
 * 由于某些操作被多个视图调用，如果在模板中嵌入业务代码，就不得不将一段代码从一个地方复制到另外一个地方
 * 这样的后果就是bug越来越多，代码维护越来越难
 *
 * 为防止上述情况发生；
 * 应该把逻辑代码和视图模板分离开
 * 只让视图负责数据显示的任务；通行的办法是先得到数据，再讲数据传递给视图
 * 当一个视图需要访问系统的数据时，你可以提供一个视图助手对象来达到目的
 *
 * 实现：
 * 如果已经搭建好一个外部框架，写一个视图层并不难（很多信息架构的问题任然存在，也是很大的内容）
 * 在一些编程语言中实现模板视图的方法是虚构一个模板系统
 * 将特定的标签解析成系统中的值，比如php
 * 如Smarty ，当然也可以用原生的php来写
 *
 * 视图要工作必须获得数据，可以定义一个视图助手来访问Request对象和其他我们需要的对象
 */
namespace Angular\View;
use Angular\Registry\Scope\RequestRegistry;

/**
 *此类的唯一功能就是访问一个Request对象，但你可以对其进行扩展来获得更多的功能
 *如果发现在视图中写了好几行代码，很可能这些代码需要放到视图助手类中
 *还可以将视图助手设计为继承层级结构，并实现多个视图助手对象
 * Class ViewHelper
 * @package Angular\View
 */
class ViewHelper{
    static public function getRequest(){
        return RequestRegistry::getRequest();   //访问Request对象
    }
}

/**
 * 效果：
 * 如何传递数据给视图层是一个要考虑的问题，因为视图并没有固定的接口来保证它所处的环境
 * 选择需要视图可以告诉系统可以告诉系统：“如果被调用，就需要拥有访问对象ABC的权利”，由系统来保证做到这一点
 *
 * 尽管可以安全的在视图中访问变量，但是为视图和助手类同时维护一个平行的系统是很麻烦的
 * 可以通过 Request SessionRegistry RequestRegistry 来为视图层动态的创建注册对象
 *
 * 模板通常是被动的，其中的值来自于上一次请求的结果，有时视图会需要一些额外的请求
 * 视图助手很适合提供这样的功能，让视图轻松获取数据
 * 不过即使是视图助手也尽量不做这样的工作，而通过使用外观模式把这些工作委托给命令对象或者领域层
 */
?>

<?php
/**
 * 实现样例
 */
$requesr = ViewHelper::getRequest();
$venue = $requesr->getObject('venue');
?>
<html>
<title>
    <?php echo $venue->getName();?>
</title>
</html>
